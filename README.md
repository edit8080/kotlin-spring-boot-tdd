# 1. 설명

이 레포지토리는 Kotlin Spring Boot 에서 red-green-refactor 패턴 기반 TDD 를 학습해보기 위한 레포지토리입니다.

# 2. 기능사항

## API

```
- PATCH `/point/{id}/charge` : 포인트를 충전한다.
- PATCH `/point/{id}/use` : 포인트를 사용한다.
- GET `/point/{id}` : 포인트를 조회한다.
- GET `/point/{id}/histories` : 포인트 내역을 조회한다.
```

## 예외 처리

- 포인트는 0 또는 음수값으로 충전/사용할 수 없음
- 잔고가 부족할 경우, 포인트 사용은 실패하여야 함

# 3. 동시성 제어 (Concurrency Control)

## 동시성 제어 방식 비교

| 비교 항목                | DB 비관적 락 | DB 낙관적 락 | Atomic (CAS) | 분산 락    | **ReentrantLock** |
| ------------------------ | ------------ | ------------ | ------------ | ---------- | ----------------- |
| **인메모리 환경 지원**   | ❌           | ❌           | ⚠️           | ❌         | ✅                |
| **여러 자원 동시 접근**  | ✅           | ✅           | ❌           | ✅         | ✅                |
| **단일 인스턴스 적합성** | ✅           | ✅           | ✅           | ⚠️         | ✅                |
| **구현 복잡도**          | 낮음         | 중간         | 낮음         | 높음       | **낮음**          |
| **외부 의존성**          | DB 필요      | DB 필요      | 없음         | Redis 필요 | **없음**          |
| **결제 도메인 적합성**   | ✅           | ⚠️           | ❌           | ✅         | ✅                |

**사용자별 ReentrantLock 적용 근거**

1. **인메모리 환경**: UserPointTable이 HashMap 기반 in-memory DB 이므로 DB lock 사용 불가
2. **여러 자원 접근**: 포인트 업데이트 + 이력 저장을 하나의 트랜잭션처럼 처리해야하므로 CAS 연산 적용이 어려움
3. **단일 인스턴스**: 현재는 분산 환경이 아니므로 JVM 레벨 Lock 만 적용
4. **결제 도메인**: 데이터 정합성이 최우선이므로 비관적 접근 방식 선택
5. **성능**: 사용자별 독립 Lock 으로 병렬 처리 성능 확보

**추후 확장 방안**:

- 실제 DB 사용 시 → `@Transactional` + 비관적 락 (`@Lock`, `SELECT ... FOR UPDATE`)으로 전환
  - 단, 포인트 충전/사용 시 여러 테이블을 동시에 수정하거나 Lock 오버헤드를 줄여야하는 목적이 강하다면 ReentrantLock 유지
- 멀티 인스턴스 배포 시 → Redisson 기반 분산 락으로 전환
